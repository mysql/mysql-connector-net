// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mysqlx_resultset.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mysqlx.Resultset {

  /// <summary>Holder for reflection information generated from mysqlx_resultset.proto</summary>
  internal static partial class MysqlxResultsetReflection {

    #region Descriptor
    /// <summary>File descriptor for mysqlx_resultset.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MysqlxResultsetReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZteXNxbHhfcmVzdWx0c2V0LnByb3RvEhBNeXNxbHguUmVzdWx0c2V0Ggxt",
            "eXNxbHgucHJvdG8iGAoWRmV0Y2hEb25lTW9yZU91dFBhcmFtcyIZChdGZXRj",
            "aERvbmVNb3JlUmVzdWx0c2V0cyILCglGZXRjaERvbmUiEAoORmV0Y2hTdXNw",
            "ZW5kZWQiqQMKDkNvbHVtbk1ldGFEYXRhEjgKBHR5cGUYASABKA4yKi5NeXNx",
            "bHguUmVzdWx0c2V0LkNvbHVtbk1ldGFEYXRhLkZpZWxkVHlwZRIMCgRuYW1l",
            "GAIgASgMEhUKDW9yaWdpbmFsX25hbWUYAyABKAwSDQoFdGFibGUYBCABKAwS",
            "FgoOb3JpZ2luYWxfdGFibGUYBSABKAwSDgoGc2NoZW1hGAYgASgMEg8KB2Nh",
            "dGFsb2cYByABKAwSEQoJY29sbGF0aW9uGAggASgEEhkKEWZyYWN0aW9uYWxf",
            "ZGlnaXRzGAkgASgNEg4KBmxlbmd0aBgKIAEoDRINCgVmbGFncxgLIAEoDRIU",
            "Cgxjb250ZW50X3R5cGUYDCABKA0ijAEKCUZpZWxkVHlwZRIICgROT05FEAAS",
            "CAoEU0lOVBABEggKBFVJTlQQAhIKCgZET1VCTEUQBRIJCgVGTE9BVBAGEgkK",
            "BUJZVEVTEAcSCAoEVElNRRAKEgwKCERBVEVUSU1FEAwSBwoDU0VUEA8SCAoE",
            "RU5VTRAQEgcKA0JJVBAREgsKB0RFQ0lNQUwQEiIUCgNSb3cSDQoFZmllbGQY",
            "ASADKAwqRAoRQ29udGVudFR5cGVfQllURVMSDgoKTk9ORV9CWVRFUxAAEgwK",
            "CEdFT01FVFJZEAESCAoESlNPThACEgcKA1hNTBADKkEKFENvbnRlbnRUeXBl",
            "X0RBVEVUSU1FEhEKDU5PTkVfREFURVRJTUUQABIICgREQVRFEAESDAoIREFU",
            "RVRJTUUQAkIZChdjb20ubXlzcWwuY2oueC5wcm90b2J1ZmIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mysqlx.MysqlxReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Mysqlx.Resultset.ContentType_BYTES), typeof(global::Mysqlx.Resultset.ContentType_DATETIME), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.FetchDoneMoreOutParams), global::Mysqlx.Resultset.FetchDoneMoreOutParams.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.FetchDoneMoreResultsets), global::Mysqlx.Resultset.FetchDoneMoreResultsets.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.FetchDone), global::Mysqlx.Resultset.FetchDone.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.FetchSuspended), global::Mysqlx.Resultset.FetchSuspended.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.ColumnMetaData), global::Mysqlx.Resultset.ColumnMetaData.Parser, new[]{ "Type", "Name", "OriginalName", "Table", "OriginalTable", "Schema", "Catalog", "Collation", "FractionalDigits", "Length", "Flags", "ContentType" }, null, new[]{ typeof(global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.Row), global::Mysqlx.Resultset.Row.Parser, new[]{ "Field" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// a hint about the higher-level encoding of a BYTES field
  ///
  /// ====== ====== ===========
  /// type   value  description
  /// ====== ====== ===========
  /// BYTES  0x0001 GEOMETRY (WKB encoding)
  /// BYTES  0x0002 JSON (text encoding)
  /// BYTES  0x0003 XML (text encoding)
  /// ====== ====== ===========
  ///
  /// .. note::
  ///   this list isn't comprehensive. As guideline: the field's value is expected
  ///   to pass a validator check on client and server if this field is set.
  ///   If the server adds more internal datatypes that rely on BLOB storage
  ///   like image manipulation, seeking into complex types in BLOBs, ... more
  ///   types will be added.
  /// </summary>
  internal enum ContentType_BYTES {
    [pbr::OriginalName("CBNONE")] Cbnone = 0,
    [pbr::OriginalName("GEOMETRY")] Geometry = 1,
    [pbr::OriginalName("JSON")] Json = 2,
    [pbr::OriginalName("XML")] Xml = 3,
  }

  /// <summary>
  /// a hint about the higher-level encoding of a DATETIME field
  ///
  /// ======   ====== ===========
  /// type     value  description
  /// ======== ====== ===========
  /// DATE     0x0001 DATETIME contains only date part
  /// DATETIME 0x0002 DATETIME contains both date and time parts
  /// ======   ====== ===========
  /// </summary>
  internal enum ContentType_DATETIME {
    [pbr::OriginalName("CDNONE")] Cdnone = 0,
    [pbr::OriginalName("DATE")] Date = 1,
    [pbr::OriginalName("DATETIME")] Datetime = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// resultsets are finished, OUT paramset is next
  /// </summary>
  internal sealed partial class FetchDoneMoreOutParams : pb::IMessage<FetchDoneMoreOutParams> {
    private static readonly pb::MessageParser<FetchDoneMoreOutParams> _parser = new pb::MessageParser<FetchDoneMoreOutParams>(() => new FetchDoneMoreOutParams());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FetchDoneMoreOutParams> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDoneMoreOutParams() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDoneMoreOutParams(FetchDoneMoreOutParams other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDoneMoreOutParams Clone() {
      return new FetchDoneMoreOutParams(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FetchDoneMoreOutParams);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FetchDoneMoreOutParams other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FetchDoneMoreOutParams other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  /// <summary>
  /// resultset and out-params are finished, but more resultsets available
  /// </summary>
  internal sealed partial class FetchDoneMoreResultsets : pb::IMessage<FetchDoneMoreResultsets> {
    private static readonly pb::MessageParser<FetchDoneMoreResultsets> _parser = new pb::MessageParser<FetchDoneMoreResultsets>(() => new FetchDoneMoreResultsets());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FetchDoneMoreResultsets> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDoneMoreResultsets() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDoneMoreResultsets(FetchDoneMoreResultsets other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDoneMoreResultsets Clone() {
      return new FetchDoneMoreResultsets(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FetchDoneMoreResultsets);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FetchDoneMoreResultsets other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FetchDoneMoreResultsets other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  /// <summary>
  /// all resultsets are finished
  /// </summary>
  internal sealed partial class FetchDone : pb::IMessage<FetchDone> {
    private static readonly pb::MessageParser<FetchDone> _parser = new pb::MessageParser<FetchDone>(() => new FetchDone());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FetchDone> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDone() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDone(FetchDone other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDone Clone() {
      return new FetchDone(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FetchDone);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FetchDone other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FetchDone other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  /// <summary>
  /// cursor is opened still the execution of PrepFetch or PrepExecute ended
  /// </summary>
  internal sealed partial class FetchSuspended : pb::IMessage<FetchSuspended> {
    private static readonly pb::MessageParser<FetchSuspended> _parser = new pb::MessageParser<FetchSuspended>(() => new FetchSuspended());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FetchSuspended> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchSuspended() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchSuspended(FetchSuspended other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchSuspended Clone() {
      return new FetchSuspended(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FetchSuspended);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FetchSuspended other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FetchSuspended other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  /// <summary>
  /// meta data of a Column
  ///
  /// .. note:: the encoding used for the different ``bytes`` fields in the meta data is externally
  ///   controlled.
  ///   .. seealso:: https://dev.mysql.com/doc/refman/8.0/en/charset-connection.html
  ///
  /// .. note::
  ///   The server may not set the ``original_{table|name}`` fields if they are equal to the plain
  ///   ``{table|name}`` field.
  ///
  ///   A client has to reconstruct it like::
  ///
  ///     if .original_name is empty and .name is not empty:
  ///       .original_name = .name
  ///
  ///     if .original_table is empty and .table is not empty:
  ///       .original_table = .table
  ///
  /// .. note::
  ///   ``compact metadata format`` can be requested by the client. In that case only ``.type`` is set and
  ///   all other fields are empty.
  ///
  /// :param type:
  ///   .. table:: Expected Datatype of Mysqlx.Resultset.Row per SQL Type for non NULL values
  ///
  ///     ================= ============ ======= ========== ====== ========
  ///     SQL Type          .type        .length .frac_dig  .flags .charset
  ///     ================= ============ ======= ========== ====== ========
  ///     TINY              SINT         x
  ///     TINY UNSIGNED     UINT         x                  x
  ///     SHORT             SINT         x
  ///     SHORT UNSIGNED    UINT         x                  x
  ///     INT24             SINT         x
  ///     INT24 UNSIGNED    UINT         x                  x
  ///     INT               SINT         x
  ///     INT UNSIGNED      UINT         x                  x
  ///     LONGLONG          SINT         x
  ///     LONGLONG UNSIGNED UINT         x                  x
  ///     DOUBLE            DOUBLE       x       x          x
  ///     FLOAT             FLOAT        x       x          x
  ///     DECIMAL           DECIMAL      x       x          x
  ///     VARCHAR,CHAR,...  BYTES        x                  x      x
  ///     GEOMETRY          BYTES
  ///     TIME              TIME         x
  ///     DATE              DATETIME     x
  ///     DATETIME          DATETIME     x
  ///     YEAR              UINT         x                  x
  ///     TIMESTAMP         DATETIME     x
  ///     SET               SET                                    x
  ///     ENUM              ENUM                                   x
  ///     NULL              BYTES
  ///     BIT               BIT          x
  ///     ================= ============ ======= ========== ====== ========
  ///
  ///   .. note:: the SQL "NULL" value is sent as an empty field value in :protobuf:msg:`Mysqlx.Resultset::Row`
  ///   .. seealso:: protobuf encoding of primitive datatypes are decribed in https://developers.google.com/protocol-buffers/docs/encoding
  ///
  ///   SINT
  ///
  ///     ``.length``
  ///       maximum number of displayable decimal digits (including minus sign) of the type
  ///
  ///       .. note::
  ///         valid range is 0-255, but usually you'll see 1-20
  ///
  ///       =============== ==
  ///       SQL Type        max digits per type
  ///       =============== ==
  ///       TINY SIGNED      4
  ///       SHORT SIGNED     6
  ///       INT24 SIGNED     8
  ///       INT SIGNED      11
  ///       LONGLONG SIGNED 20
  ///       =============== ==
  ///
  ///       .. seealso:: definition of ``M`` in https://dev.mysql.com/doc/refman/8.0/en/numeric-type-overview.html
  ///
  ///     ``value``
  ///       variable length encoded signed 64 integer
  ///
  ///   UINT
  ///
  ///     ``.flags &amp; 1`` (zerofill)
  ///       the client has to left pad with 0's up to .length
  ///
  ///     ``.length``
  ///       maximum number of displayable decimal digits of the type
  ///
  ///       .. note::
  ///         valid range is 0-255, but usually you'll see 1-20
  ///
  ///       ================= ==
  ///       SQL Type          max digits per type
  ///       ================= ==
  ///       TINY UNSIGNED      3
  ///       SHORT UNSIGNED     5
  ///       INT24 UNSIGNED     8
  ///       INT UNSIGNED      10
  ///       LONGLONG UNSIGNED 20
  ///       ================= ==
  ///
  ///       .. seealso:: definition of ``M`` in https://dev.mysql.com/doc/refman/8.0/en/numeric-type-overview.html
  ///
  ///     ``value``
  ///       variable length encoded unsigned 64 integer
  ///
  ///   BIT
  ///
  ///     ``.length``
  ///       maximum number of displayable binary digits
  ///
  ///       .. note:: valid range for M of the ``BIT`` type is 1 - 64
  ///       .. seealso:: https://dev.mysql.com/doc/refman/8.0/en/numeric-type-overview.html
  ///
  ///     ``value``
  ///       variable length encoded unsigned 64 integer
  ///
  ///   DOUBLE
  ///
  ///     ``.length``
  ///       maximum number of displayable decimal digits (including the decimal point and ``.fractional_digits``)
  ///
  ///     ``.fractional_digits``
  ///       maximum number of displayable decimal digits following the decimal point
  ///
  ///     ``value``
  ///       encoded as Protobuf's 'double'
  ///
  ///   FLOAT
  ///
  ///     ``.length``
  ///       maximum number of displayable decimal digits (including the decimal point and ``.fractional_digits``)
  ///
  ///     ``.fractional_digits``
  ///       maximum number of displayable decimal digits following the decimal point
  ///
  ///     ``value``
  ///       encoded as Protobuf's 'float'
  ///
  ///   BYTES, ENUM
  ///     BYTES is used for all opaque byte strings that may have a charset
  ///
  ///       * TINYBLOB, BLOB, MEDIUMBLOB, LONGBLOB
  ///       * TINYTEXT, TEXT, MEDIUMTEXT, LONGTEXT
  ///       * VARCHAR, VARBINARY
  ///       * CHAR, BINARY
  ///       * ENUM
  ///
  ///     ``.length``
  ///       the maximum length of characters of the underlying type
  ///
  ///     ``.flags &amp; 1`` (rightpad)
  ///       if the length of the field is less than ``.length``, the receiver is
  ///       supposed to add padding characters to the right end of the string.
  ///       If the ``.charset`` is "binary", the padding character is ``0x00``,
  ///       otherwise it is a space character as defined by that character set.
  ///
  ///       ============= ======= ======== =======
  ///       SQL Type      .length .charset .flags
  ///       ============= ======= ======== =======
  ///       TINYBLOB      256     binary
  ///       BLOB          65535   binary
  ///       VARCHAR(32)   32      utf8
  ///       VARBINARY(32) 32      utf8_bin
  ///       BINARY(32)    32      binary   rightpad
  ///       CHAR(32)      32      utf8     rightpad
  ///       ============= ======= ======== =======
  ///
  ///     ``value``
  ///       sequence of bytes with added one extra '\0' byte at the end. To obtain the
  ///       original string, the extra '\0' should be removed.
  ///       .. note:: the length of the string can be acquired with protobuf's field length() method
  ///         length of sequence-of-bytes = length-of-field - 1
  ///       .. note:: the extra byte allows to distinguish between a NULL and empty byte sequence
  ///
  ///   TIME
  ///     A time value.
  ///
  ///     ``value``
  ///       the following bytes sequence:
  ///
  ///         ``| negate [ | hour | [ | minutes | [ | seconds | [ | useconds | ]]]]``
  ///
  ///       * negate - one byte, should be one of: 0x00 for "+", 0x01 for "-"
  ///       * hour - optional variable length encoded unsigned64 value for the hour
  ///       * minutes - optional variable length encoded unsigned64 value for the minutes
  ///       * seconds - optional variable length encoded unsigned64 value for the seconds
  ///       * useconds - optional variable length encoded unsigned64 value for the microseconds
  ///
  ///       .. seealso:: protobuf encoding in https://developers.google.com/protocol-buffers/docs/encoding
  ///       .. note:: hour, minutes, seconds, useconds are optional if all the values to the right are 0
  ///
  ///       Example: 0x00 -> +00:00:00.000000
  ///
  ///   DATETIME
  ///     A date or date and time value.
  ///
  ///     ``value``
  ///       a sequence of variants, arranged as follows:
  ///
  ///         ``| year | month | day | [ | hour | [ | minutes | [ | seconds | [ | useconds | ]]]]``
  ///
  ///       * year - variable length encoded unsigned64 value for the year
  ///       * month - variable length encoded unsigned64 value for the month
  ///       * day - variable length encoded unsigned64 value for the day
  ///       * hour - optional variable length encoded unsigned64 value for the hour
  ///       * minutes - optional variable length encoded unsigned64 value for the minutes
  ///       * seconds - optional variable length encoded unsigned64 value for the seconds
  ///       * useconds - optional variable length encoded unsigned64 value for the microseconds
  ///
  ///       .. note:: hour, minutes, seconds, useconds are optional if all the values to the right are 0
  ///
  ///     ``.flags &amp; 1`` (timestamp)
  ///
  ///       ============= =======
  ///       SQL Type      .flags
  ///       ============= =======
  ///       DATETIME
  ///       TIMESTAMP     1
  ///
  ///   DECIMAL
  ///     An arbitrary length number. The number is encoded as a single byte
  ///     indicating the position of the decimal point followed by the Packed BCD
  ///     encoded number. Packed BCD is used to simplify conversion to and
  ///     from strings and other native arbitrary precision math datatypes.
  ///     .. seealso:: packed BCD in https://en.wikipedia.org/wiki/Binary-coded_decimal
  ///
  ///     ``.length``
  ///       maximum number of displayable decimal digits (*excluding* the decimal point and sign, but including ``.fractional_digits``)
  ///
  ///       .. note:: should be in the range of 1 - 65
  ///
  ///     ``.fractional_digits``
  ///       is the decimal digits to display out of length
  ///
  ///       .. note:: should be in the range of 0 - 30
  ///
  ///     ``value``
  ///       the following bytes sequence:
  ///
  ///         ``| scale | BCD | sign | [0x0] |``
  ///
  ///       * scale - 8bit scale value (number of decimal digit after the '.')
  ///       * BCD - BCD encoded digits (4 bits for each digit)
  ///       * sign - sign encoded on 4 bits (0xc = "+", 0xd = "-")
  ///       * 0x0 - last 4bits if length(digits) % 2 == 0
  ///
  ///       Example: x04 0x12 0x34 0x01 0xd0 -> -12.3401
  ///
  ///   SET
  ///     A list of strings representing a SET of values.
  ///
  ///     ``value``
  ///       A sequence of 0 or more of protobuf's bytes (length prepended octets) or one of
  ///       the special sequences with a predefined meaning listed below.
  ///
  ///       Example (length of the bytes array shown in brackets):
  ///         * ``[0]`` - the NULL value
  ///         * ``[1] 0x00`` - a set containing a blank string ''
  ///         * ``[1] 0x01`` - this would be an invalid value, but is to be treated as the empty set
  ///         * ``[2] 0x01 0x00`` - a set with a single item, which is the '\0' character
  ///         * ``[8] 0x03 F O O 0x03 B A R`` - a set with 2 items: FOO,BAR
  ///
  /// :param name: name of the column
  /// :param original_name: name of the column before an alias was applied
  /// :param table: name of the table the column orginates from
  /// :param original_table: name of the table the column orginates from before an alias was applied
  /// :param schema: schema the column originates from
  /// :param catalog:
  ///   catalog the schema originates from
  ///
  ///   .. note::
  ///     as there is current no support for catalogs in MySQL, don't expect this field to be set.
  ///     In the MySQL C/S protocol the field had the value ``def`` all the time.
  ///
  /// :param fractional_digits: displayed factional decimal digits for floating point and fixed point numbers
  /// :param length: maximum count of displayable characters of .type
  /// :param flags:
  ///   ``.type`` specific flags
  ///
  ///   ======= ====== ===========
  ///   type    value  description
  ///   ======= ====== ===========
  ///   UINT    0x0001 zerofill
  ///   DOUBLE  0x0001 unsigned
  ///   FLOAT   0x0001 unsigned
  ///   DECIMAL 0x0001 unsigned
  ///   BYTES   0x0001 rightpad
  ///   ======= ====== ===========
  ///
  ///   ====== ================
  ///   value  description
  ///   ====== ================
  ///   0x0010 NOT_NULL
  ///   0x0020 PRIMARY_KEY
  ///   0x0040 UNIQUE_KEY
  ///   0x0080 MULTIPLE_KEY
  ///   0x0100 AUTO_INCREMENT
  ///   ====== ================
  ///
  ///   default: 0
  /// :param content_type:
  ///   a hint about the higher-level encoding of a BYTES field, for more informations
  ///   please refer to Mysqlx.Resultset.ContentType_BYTES enum.
  /// </summary>
  internal sealed partial class ColumnMetaData : pb::IMessage<ColumnMetaData> {
    private static readonly pb::MessageParser<ColumnMetaData> _parser = new pb::MessageParser<ColumnMetaData>(() => new ColumnMetaData());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ColumnMetaData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColumnMetaData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColumnMetaData(ColumnMetaData other) : this() {
      type_ = other.type_;
      name_ = other.name_;
      originalName_ = other.originalName_;
      table_ = other.table_;
      originalTable_ = other.originalTable_;
      schema_ = other.schema_;
      catalog_ = other.catalog_;
      collation_ = other.collation_;
      fractionalDigits_ = other.fractionalDigits_;
      length_ = other.length_;
      flags_ = other.flags_;
      contentType_ = other.contentType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColumnMetaData Clone() {
      return new ColumnMetaData(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType type_ = 0;
    /// <summary>
    /// datatype of the field in a row
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private pb::ByteString name_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "original_name" field.</summary>
    public const int OriginalNameFieldNumber = 3;
    private pb::ByteString originalName_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString OriginalName {
      get { return originalName_; }
      set {
        originalName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "table" field.</summary>
    public const int TableFieldNumber = 4;
    private pb::ByteString table_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Table {
      get { return table_; }
      set {
        table_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "original_table" field.</summary>
    public const int OriginalTableFieldNumber = 5;
    private pb::ByteString originalTable_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString OriginalTable {
      get { return originalTable_; }
      set {
        originalTable_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "schema" field.</summary>
    public const int SchemaFieldNumber = 6;
    private pb::ByteString schema_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Schema {
      get { return schema_; }
      set {
        schema_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "catalog" field.</summary>
    public const int CatalogFieldNumber = 7;
    private pb::ByteString catalog_ = pb::ByteString.Empty;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Catalog {
      get { return catalog_; }
      set {
        catalog_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "collation" field.</summary>
    public const int CollationFieldNumber = 8;
    private ulong collation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Collation {
      get { return collation_; }
      set {
        collation_ = value;
      }
    }

    /// <summary>Field number for the "fractional_digits" field.</summary>
    public const int FractionalDigitsFieldNumber = 9;
    private uint fractionalDigits_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint FractionalDigits {
      get { return fractionalDigits_; }
      set {
        fractionalDigits_ = value;
      }
    }

    /// <summary>Field number for the "length" field.</summary>
    public const int LengthFieldNumber = 10;
    private uint length_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Length {
      get { return length_; }
      set {
        length_ = value;
      }
    }

    /// <summary>Field number for the "flags" field.</summary>
    public const int FlagsFieldNumber = 11;
    private uint flags_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Flags {
      get { return flags_; }
      set {
        flags_ = value;
      }
    }

    /// <summary>Field number for the "content_type" field.</summary>
    public const int ContentTypeFieldNumber = 12;
    private uint contentType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ContentType {
      get { return contentType_; }
      set {
        contentType_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ColumnMetaData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ColumnMetaData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Name != other.Name) return false;
      if (OriginalName != other.OriginalName) return false;
      if (Table != other.Table) return false;
      if (OriginalTable != other.OriginalTable) return false;
      if (Schema != other.Schema) return false;
      if (Catalog != other.Catalog) return false;
      if (Collation != other.Collation) return false;
      if (FractionalDigits != other.FractionalDigits) return false;
      if (Length != other.Length) return false;
      if (Flags != other.Flags) return false;
      if (ContentType != other.ContentType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Type != 0) hash ^= Type.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (OriginalName.Length != 0) hash ^= OriginalName.GetHashCode();
      if (Table.Length != 0) hash ^= Table.GetHashCode();
      if (OriginalTable.Length != 0) hash ^= OriginalTable.GetHashCode();
      if (Schema.Length != 0) hash ^= Schema.GetHashCode();
      if (Catalog.Length != 0) hash ^= Catalog.GetHashCode();
      if (Collation != 0UL) hash ^= Collation.GetHashCode();
      if (FractionalDigits != 0) hash ^= FractionalDigits.GetHashCode();
      if (Length != 0) hash ^= Length.GetHashCode();
      if (Flags != 0) hash ^= Flags.GetHashCode();
      if (ContentType != 0) hash ^= ContentType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Type != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Name);
      }
      if (OriginalName.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(OriginalName);
      }
      if (Table.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(Table);
      }
      if (OriginalTable.Length != 0) {
        output.WriteRawTag(42);
        output.WriteBytes(OriginalTable);
      }
      if (Schema.Length != 0) {
        output.WriteRawTag(50);
        output.WriteBytes(Schema);
      }
      if (Catalog.Length != 0) {
        output.WriteRawTag(58);
        output.WriteBytes(Catalog);
      }
      if (Collation != 0UL) {
        output.WriteRawTag(64);
        output.WriteUInt64(Collation);
      }
      if (FractionalDigits != 0) {
        output.WriteRawTag(72);
        output.WriteUInt32(FractionalDigits);
      }
      if (Length != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(Length);
      }
      if (Flags != 0) {
        output.WriteRawTag(88);
        output.WriteUInt32(Flags);
      }
      if (ContentType != 0) {
        output.WriteRawTag(96);
        output.WriteUInt32(ContentType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Name);
      }
      if (OriginalName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(OriginalName);
      }
      if (Table.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Table);
      }
      if (OriginalTable.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(OriginalTable);
      }
      if (Schema.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Schema);
      }
      if (Catalog.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Catalog);
      }
      if (Collation != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Collation);
      }
      if (FractionalDigits != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FractionalDigits);
      }
      if (Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Length);
      }
      if (Flags != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Flags);
      }
      if (ContentType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContentType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ColumnMetaData other) {
      if (other == null) {
        return;
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.OriginalName.Length != 0) {
        OriginalName = other.OriginalName;
      }
      if (other.Table.Length != 0) {
        Table = other.Table;
      }
      if (other.OriginalTable.Length != 0) {
        OriginalTable = other.OriginalTable;
      }
      if (other.Schema.Length != 0) {
        Schema = other.Schema;
      }
      if (other.Catalog.Length != 0) {
        Catalog = other.Catalog;
      }
      if (other.Collation != 0UL) {
        Collation = other.Collation;
      }
      if (other.FractionalDigits != 0) {
        FractionalDigits = other.FractionalDigits;
      }
      if (other.Length != 0) {
        Length = other.Length;
      }
      if (other.Flags != 0) {
        Flags = other.Flags;
      }
      if (other.ContentType != 0) {
        ContentType = other.ContentType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            type_ = (global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType) input.ReadEnum();
            break;
          }
          case 18: {
            Name = input.ReadBytes();
            break;
          }
          case 26: {
            OriginalName = input.ReadBytes();
            break;
          }
          case 34: {
            Table = input.ReadBytes();
            break;
          }
          case 42: {
            OriginalTable = input.ReadBytes();
            break;
          }
          case 50: {
            Schema = input.ReadBytes();
            break;
          }
          case 58: {
            Catalog = input.ReadBytes();
            break;
          }
          case 64: {
            Collation = input.ReadUInt64();
            break;
          }
          case 72: {
            FractionalDigits = input.ReadUInt32();
            break;
          }
          case 80: {
            Length = input.ReadUInt32();
            break;
          }
          case 88: {
            Flags = input.ReadUInt32();
            break;
          }
          case 96: {
            ContentType = input.ReadUInt32();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ColumnMetaData message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    internal static partial class Types {
      internal enum FieldType {
        [pbr::OriginalName("NONE")] None = 0,
        [pbr::OriginalName("SINT")] Sint = 1,
        [pbr::OriginalName("UINT")] Uint = 2,
        [pbr::OriginalName("DOUBLE")] Double = 5,
        [pbr::OriginalName("FLOAT")] Float = 6,
        [pbr::OriginalName("BYTES")] Bytes = 7,
        [pbr::OriginalName("TIME")] Time = 10,
        [pbr::OriginalName("DATETIME")] Datetime = 12,
        [pbr::OriginalName("SET")] Set = 15,
        [pbr::OriginalName("ENUM")] Enum = 16,
        [pbr::OriginalName("BIT")] Bit = 17,
        [pbr::OriginalName("DECIMAL")] Decimal = 18,
      }

    }
    #endregion

  }

  /// <summary>
  ///   Row in a Resultset
  ///
  ///   a row is represented as a list of fields encoded as byte blobs.
  ///   Blob of size 0 represents the NULL value. Otherwise, if it contains at least
  ///   one byte, it encodes a non-null value of the field using encoding appropriate for the
  ///   type of the value given by ``ColumnMetadata``, as specified
  ///   in the :protobuf:msg:`Mysqlx.Resultset::ColumnMetaData` description.
  /// </summary>
  internal sealed partial class Row : pb::IMessage<Row> {
    private static readonly pb::MessageParser<Row> _parser = new pb::MessageParser<Row>(() => new Row());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Row> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Row() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Row(Row other) : this() {
      field_ = other.field_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Row Clone() {
      return new Row(this);
    }

    /// <summary>Field number for the "field" field.</summary>
    public const int FieldFieldNumber = 1;
    private static readonly pb::FieldCodec<pb::ByteString> _repeated_field_codec
        = pb::FieldCodec.ForBytes(10);
    private readonly pbc::RepeatedField<pb::ByteString> field_ = new pbc::RepeatedField<pb::ByteString>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<pb::ByteString> Field {
      get { return field_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Row);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Row other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!field_.Equals(other.field_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= field_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      field_.WriteTo(output, _repeated_field_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += field_.CalculateSize(_repeated_field_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Row other) {
      if (other == null) {
        return;
      }
      field_.Add(other.field_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            field_.AddEntriesFrom(input, _repeated_field_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
